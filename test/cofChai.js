const cof = require('../src/cof'); // Імпортуємо функцію cof
const { expect } = require('chai'); // Імпортуємо expect з Chai
const Mtrx = require('..'); // Імпортуємо конструктор Mtrx

describe('cof', function() {

  it('повинна повернути нову матрицю без i рядка та j стовпця', function() {
    // Початкова матриця
    let a = [[1, 2, 3], [2, 3, 4], [3, 4, 5]];

    // Перевіряємо, що результат видалення рядка та стовпця відповідає очікуваному
    expect(cof(a, 1, 1)).to.deep.equal([[1, 3], [3, 5]]);

    // Перевіряємо, що початкова матриця не була змінена
    expect(a).to.deep.equal([[1, 2, 3], [2, 3, 4], [3, 4, 5]]);

    // Перевіряємо інший випадок видалення рядка та стовпця
    expect(cof(a, 0, 0)).to.deep.equal([[3, 4], [4, 5]]);
  });

  it('повинна повернути ту ж саму матрицю, якщо i та j поза межами діапазону', function() {
    // Початкова матриця
    let a = [[1, 2], [3, 4]];

    // Перевіряємо, що при виході за межі індексів повертається початкова матриця
    expect(cof(a, 2, 2)).to.deep.equal([[1, 2], [3, 4]]);
    expect(a).to.deep.equal([[1, 2], [3, 4]]);

    // Перевіряємо випадок з від'ємними індексами
    expect(cof(a, -2, -5)).to.deep.equal([[1, 2], [3, 4]]);
  });

  it('повинна повернути новий Mtrx, якщо матриця є об\'єктом Mtrx', function() {
    // Початкова матриця та об\'єкт Mtrx
    let a = [[2, 3, 4], [4, 5, 6], [8, 0, 9]];
    let m = new Mtrx(a);
    let n = new Mtrx([[2, 4], [8, 9]]);

    // Перевіряємо, що результат роботи функції cof для об\'єкта Mtrx повертає новий об\'єкт Mtrx
    expect(cof(m, 1, 1)).to.deep.equal(n);
  });

});
